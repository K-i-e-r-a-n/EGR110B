#pragma config(Sensor, S1,     sonar,          sensorSONAR)
#pragma config(Sensor, S2,     limit,          sensorTouch)
#pragma config(Sensor, S3,     none,           sensorNone)
#pragma config(Sensor, S4,     none,           sensorNone)
#pragma config(Motor,  motorA,          claw,          tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          left,          tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          right,         tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define TURN_POWER (5)
#define CLAW_POWER (-10)
#define CLAW_CLOSE_POWER (30)
#define CLAW_HOLD 20
#define TURN_BACK_POWER (-5)
#define SEARCH_DISTANCE 30
#define MIN_OBJ_DIST 15

int max(int a, int b)
{
	if (a > b)
		return a;
	else
		return b;
}

int min(int a, int b)
{
	if (a < b)
		return a;
	else
		return b;
}

//intializes the robot
void init()
{
	motor[claw] = CLAW_POWER; //moves the claw all the way back
	while (SensorValue[limit] != 1){}
	motor[claw] = 0;
}

int searchForObject()
{
	int ei = nMotorEncoder[left];
	nxtDisplayCenteredTextLine(2, "SEARCH MODE");
	motor[right] = -TURN_POWER;
	motor[left] = TURN_POWER;
	int distance = SensorValue[sonar];
	while(distance > SEARCH_DISTANCE)
	{
		nxtDisplayCenteredTextLine(3, "Distance: %d", SensorValue[sonar]);
		distance = SensorValue[sonar];
	}
	long theta1 = nMotorEncoder[left];
	long theta2 = nMotorEncoder[left];
	nxtDisplayCenteredTextLine(2, "SEARCH: FOUND OBJ");
	while(abs(SensorValue[sonar] - distance) < 10)
	{
		nxtDisplayCenteredTextLine(3, "Distance: %d", SensorValue[sonar]);
		theta2 = nMotorEncoder[left];
	}
	long thetaMid = (theta1+theta2)/2;
	motor[right] = -TURN_BACK_POWER;
	motor[left] = TURN_BACK_POWER;
	nxtDisplayCenteredTextLine(2, "SEARCH: CENTERING");
	while (abs(nMotorEncoder[left] - thetaMid) > 10)
	{
		nxtDisplayCenteredTextLine(3, "Error: %i", nMotorEncoder[left] - thetaMid);
		if (nMotorEncoder[left] > thetaMid)
		{
			motor[right] = -TURN_BACK_POWER;
			motor[left] = TURN_BACK_POWER;
		}
		else
		{
			motor[right] = TURN_BACK_POWER;
			motor[left] = -TURN_BACK_POWER;
		}
	}
	motor[right] = 0;
	motor[left] = 0;
	int ef = nMotorEncoder[left];
	return ef - ei;
}

long retrieve()
{
	long position = nMotorEncoder[left];
	nxtDisplayCenteredTextLine(2, "RETRIEVAL MODE"); //debug text
	int speed = 50;
	while (SensorValue[sonar] > MIN_OBJ_DIST)
	{
		nxtDisplayCenteredTextLine(3, "Distance: %d", SensorValue[sonar]);
		speed = min(25, max(SensorValue[sonar], 10));
		motor[right] = speed;
		motor[left] = speed;
	}
	motor[right] = 0;
	motor[left] = 0;
	return position;
}

void closeClaw()
{
	int startPos = nMotorEncoder[claw];
	nxtDisplayCenteredTextLine(3, "Claw: %d", nMotorEncoder[claw]);
	int target = 90;
	while(abs(startPos - nMotorEncoder[claw]) < target)
	{
		motor[claw] = CLAW_CLOSE_POWER;
	}
	motor[claw] = CLAW_HOLD;
}

void backUp(long position)
{
	motor[right] = 50;
	motor[left] = -50;
	while (nMotorEncoder[left] > position){}
	motor[right] = 0;
	motor[left] = 0;
}

/////////////////////
//	Task: Main
/////////////////////
task main()
{
	init();
	int encoderDistance = searchForObject();
	long distance = retrieve();
	closeClaw();
	backUp(distance);
}
